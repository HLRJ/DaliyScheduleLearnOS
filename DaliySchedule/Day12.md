# day12   

RISC-V，MIPS,Interl x86  

指令系统的相似性是因为所有计算机都是基于相似基本原理的硬件技术构建的，且因为有些基本操作是所有计算机都必须提供的。
此外，计算机设计人员都有一个共同目标：找到让构建硬件和编译器容易，同时最大化性能且最小化成本和资源的语言。


符合硬件简单的设计原则：操作数数量可变的硬件比固定数量的硬件更复杂。  

硬件设计三条基本原则之一：  

1.简单源于规整  

2.更少则更快  

数量过多的寄存器可能会增加时钟周期，因为电信号传输的距离越远，所花费的时间就越长。

3.优秀的设计需要适当的折中。  

## 指令与并行性：同步  

当任务之间相互独立时，并行执行更为容易，但通常任务之间需要协作。
协作通常意味着一些任务正在写入其他任务必须读取的值。
需要知道任务何时完成写入以便其他任务安全地读出，因此任务之间需要同步。
如果他们不同步，则存在数据竞争的危险，那么程序的结果会根据事件发生的次序而改变。

在多处理器中实现同步所需的关键是一组硬件原语，能够提供以原子方式读取和修改内存单元的能力。
也就是说，在内存单元的读取和写入之间不能插入其他任何操作。如果没有这样的能力，构建基本同步原语的成本将会很高（疯狂加锁？），并会随着处理器数量的增加而急剧增加。

通常，体系结构设计人员不希望用户使用基本的硬件原语，而是期望系统程序员使用原语来构建同步库，这个过程通常复杂且棘手。 

原子交换原语。假设要构建一个简单的锁变量，其中值0用于表示锁变量可用，值1用于表示锁变量已被占用。处理器尝试通过将寄存器中的1与该锁变量对应的内存地址的值进行交换来设置加锁。
如果某个其他处理器已声明访问该锁变量，则交换指令的返回值为1，表明该锁已被其他处理器占用，否则为0，表示加锁成功。在后一种情况下，锁变量的值变为1，以防止其他处理器也加锁成功。

例如，考虑两个处理器尝试同时进行交换操作：这种竞争会被阻止，因为其中一个处理器将首先执行交换，并返回0，而第二个处理器在进行交换时将返回1。使用交换原语实现同步的关键是操作的原子性：交换是不可分割的，
硬件将对两个同时发生的交换进行排序。尝试以这种方式设置同步变量的两个处理器都不可能认为它们同时设置了变量。

另一种方法是使用指令对，其中第二条指令返回一个值，该值表示该指令对是否被原子执行。如果任何处理器执行的所有其他操作都发生在该对指令之前或之后，
则该指令对实际上是原子的。因此，当指令对实际上是原子操作时，没有其他处理器可以在指令对之间改变值。

在risc-v中，这对指令指的是一个成为保留加载双字的特殊加载指令和一个称为条件存储双字的特殊存储指令。
这些指令按序使用：如果保留加载指令指定的内存位置的内容在条件存储指令执行到同一地址之前发生了变化，则条件存储指令失败且不会将值写入内存。
条件存储指令定义为将（可能是不同的）寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为0，如果失败则更改为非零值。因此，sc.d 指定了三个寄存器：
一个用于保存地址，一个用于指示原子操作失败或成功，还有一个用于如果成功则将值存储在内存中。由于保留加载指令返回初始值，并且条件存储指令仅在成功时返回0，因此以下序列在寄存器X20中指定的内存位置上实现原子交换

虽然同步是为多处理器而提出的，但原子交换对于单个处理器操作系统中处理多个进程也很有用。为了确保单个处理器中的执行不受任何干扰，如果处理器在两个指令对之间进行上下文切换，则条件存储也会失败。

编译器将C程序转换为机器能理解的符号形式————汇编语言程序。   

由于汇编语言是高层软件的接口，因此汇编器还可以处理机器指令的常见变体，就像这些变体是它自己的指令一样。硬件不需要实现这些指令；然后，它们在汇编语言中的出现简化了程序转换和编程。这类指令成为伪指令。

伪指令：一种汇编指令的常见变体，可以把它看作汇编语言指令。 

链接器，完全重新翻译是对计算资源的严重浪费。这种重复对于标准库程序来说尤其浪费，因为程序员将要编译和汇编根据定义几乎永远不会改变的例程。  
另一种方法是独立编译和汇编每个过程，因此更改一行代码只需要编译和汇编一个过程。这种替代方案需要一个新的系统程序，称为链接编辑器或链接器，它将所有独立汇编的机器语言程序“缝合”
在一起。链接器有用的原因是修正代码要比重新编译和重新汇编快得多。   

链接器的工作有三个步骤：  
1.将代码和数据模块按符号特征放入内存。  
2.决定数据和指令标签的地址。  
3.修正内部和外部引用。  

可执行文件：一种具有目标文件格式的功能程序，不包含未解析的引用。它可以包含符号表和调试信息。
“剥离的可执行文件”  不包含这些信息，可以包括用于加载器的重定位信息。  

加载器：将目标程序放在主存中以准备执行的系统程序。  

加载器在UNIX系统中遵循以下步骤：  
- 1.读取可执行文件首部以确定正文段和数据段的大小。  
- 2.为正文和数据创建足够大的地址空间。  
- 3.将可执行文件中的指令和数据复制到内存中。 
- 4.将主程序的参数（如果有）复制到栈顶。  
- 5.初始化处理器寄存器并将栈指针指向第一个空闲位置。
- 6.跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程。当主例程返回时，启动例程通过exit系统调用终止程序。





